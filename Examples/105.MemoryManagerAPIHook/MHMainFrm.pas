unit MHMainFrm;


interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,
  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls, Vcl.ExtCtrls,
  Z.Status, Z.PascalStrings, Z.Core, Z.UnicodeMixedLib, Z.ListEngine;

type
  TMHMainForm = class(TForm)
    Memo: TMemo;
    Panel1: TPanel;
    Button1: TButton;
    Button2: TButton;
    Button3: TButton;
    Button4: TButton;
    Button5: TButton;
    procedure Button1Click(Sender: TObject);
    procedure FormCreate(Sender: TObject);
    procedure Button2Click(Sender: TObject);
    procedure Button3Click(Sender: TObject);
    procedure Button4Click(Sender: TObject);
    procedure Button5Click(Sender: TObject);
  private
    { Private declarations }
  public
    { Public declarations }
    procedure DoStatusMethod(AText: SystemString; const ID: Integer);
  end;

var
  MHMainForm: TMHMainForm;

implementation

{$R *.dfm}


uses Z.MH1, Z.MH2, Z.MH3, Z.MH;

procedure TMHMainForm.Button1Click(Sender: TObject);

  procedure leakproc(x, m: Integer);
  begin
    GetMemory(x);
    if x > m then
        leakproc(x - 1, m);
  end;

begin
  Z.MH.BeginMemoryHook_1;
  leakproc(100, 98);
  Z.MH.EndMemoryHook_1;

  // 这里我们会发现泄漏
  DoStatus('leakproc函数分配了 %d 字节的内存', [Z.MH.GetHookMemorySize_1]);

  Z.MH.GetHookPtrList_1.ProgressP(procedure(NPtr: Pointer; uData: NativeUInt)
    begin
      DoStatus('泄漏的地址:0x%s', [IntToHex(NativeUInt(NPtr), sizeof(Pointer) * 2)]);
      DoStatus(NPtr, uData, 80);

      // 现在我们可以直接释放该地址
      Dispose(NPtr);

      DoStatus('已成功释放 地址:0x%s 占用了 %d 字节内存', [IntToHex(NativeUInt(NPtr), sizeof(Pointer) * 2), uData]);
    end);
end;

procedure TMHMainForm.Button2Click(Sender: TObject);
type
  PMyRec = ^TMyRec;

  TMyRec = record
    s1: string;
    s2: string;
    s3: TPascalString;
    obj: TObject;
  end;

var
  p: PMyRec;
begin
  Z.MH.BeginMemoryHook_1;
  new(p);
  p^.s1 := #7#8#9;
  p^.s2 := #$20#$20#$20#$20#$20#$20#$20#$20#$20#$20#$20#$20;
  p^.s3.Text := #1#2#3#4#5#6;
  p^.obj := TObject.Create;
  Z.MH.EndMemoryHook_1;

  // 这里我们会发现泄漏
  DoStatus('TMyRec总分分配了 %d 次内存，占用 %d 字节空间，', [Z.MH.GetHookPtrList_1.Count, Z.MH.GetHookMemorySize_1]);

  Z.MH.GetHookPtrList_1.ProgressP(procedure(NPtr: Pointer; uData: NativeUInt)
    begin
      DoStatus('泄漏的地址:0x%s', [IntToHex(NativeUInt(NPtr), sizeof(Pointer) * 2)]);
      DoStatus(NPtr, uData, 80);

      // 现在我们可以直接释放该地址
      FreeMem(NPtr);

      DoStatus('已成功释放 地址:0x%s 占用了 %d 字节内存', [IntToHex(NativeUInt(NPtr), sizeof(Pointer) * 2), uData]);
    end);
end;

procedure TMHMainForm.DoStatusMethod(AText: SystemString; const ID: Integer);
begin
  Memo.Lines.Add(AText);
end;

procedure TMHMainForm.FormCreate(Sender: TObject);
begin
  AddDoStatusHook(Self, DoStatusMethod);
end;

procedure TMHMainForm.Button3Click(Sender: TObject);
type
  PMyRec = ^TMyRec;

  TMyRec = record
    s1: string;
    p: PMyRec;
  end;

var
  p: PMyRec;
  i: Integer;
begin
  // 10万次的反复勾，反复释放
  // 这种场景情况，可以用于统计你的程序开销，记录内存消耗
  for i := 0 to 10 * 10000 do
    begin
      Z.MH2.BeginMemoryHook(4);
      new(p);
      p^.s1 := '12345';
      new(p^.p);
      p^.p^.s1 := '54321';
      Z.MH2.EndMemoryHook;

      Z.MH2.GetHookPtrList.ProgressP(procedure(NPtr: Pointer; uData: NativeUInt)
        begin
          // 现在我们可以释放该地址
          FreeMem(NPtr);
        end);
    end;
end;

procedure TMHMainForm.Button4Click(Sender: TObject);
type
  PMyRec = ^TMyRec;

  TMyRec = record
    s1: string;
    p: PMyRec;
  end;

var
  p: PMyRec;
  i: Integer;
  hl: TPointerHashNativeUIntList;
begin
  // 20万次的大批量记录内存申请，最后一次性释放
  // 这种场景情况，可以用于批量释放泄漏的内存

  // 我们内建20万个Hash数组进行存储
  // BeginMemoryHook的参数越大，面对对大批量存储的高频率记录性能就越好，但也越消耗内存
  Z.MH3.BeginMemoryHook(200000);

  for i := 0 to 20 * 10000 do
    begin
      new(p);
      new(p^.p);
      // 模拟字符串赋值，高频率触发Realloc调用
      p^.s1 := '111111111111111';
      p^.s1 := '1111111111111111111111111111111111';
      p^.s1 := '11111111111111111111111111111111111111111111111111111111111111';
      p^.p^.s1 := '1';
      p^.p^.s1 := '11111111111111111111';
      p^.p^.s1 := '1111111111111111111111111111111111111';
      p^.p^.s1 := '11111111111111111111111111111111111111111111111111111111111111111111111111';

      if i mod 99999 = 0 then
        begin
          // 这里是迭代调用，我们不记录，将MH_3.MemoryHooked设置为False即可
          Z.MH3.GetMemoryHooked.V := False;
          Button1Click(nil);
          Application.ProcessMessages;
          // 继续记录内存申请
          Z.MH3.GetMemoryHooked.V := True;
        end;
    end;
  Z.MH3.EndMemoryHook;

  DoStatus('总共内存分配 %d 次 占用 %s 空间，地址跨度为：%s ', [Z.MH3.GetHookPtrList.Count, umlSizeToStr(Z.MH3.GetHookMemorySize).Text,
    umlSizeToStr(NativeUInt(Z.MH3.GetHookMemoryMaximumPtr) - NativeUInt(Z.MH3.GetHookMemoryMinimizePtr)).Text]);

  Z.MH3.GetHookPtrList.ProgressP(procedure(NPtr: Pointer; uData: NativeUInt)
    begin
      // 现在我们可以释放该地址
      FreeMem(NPtr);
    end);
  Z.MH3.GetHookPtrList.PrintHashReport;
  Z.MH3.GetHookPtrList.SetHashBlockCount(0);
end;

procedure TMHMainForm.Button5Click(Sender: TObject);

var
  s: string;
  sptr: PString;
begin
  Z.MH1.BeginMemoryHook(16);

  Memo.Lines.Add('123'); // 因为没有前后文参考，这里的Realloc和GetMem均不会被记录
  s := '12345';           // 因为s字符串在调用开始时已经初始化，没有前后文参考，这里的Realloc不会被记录

  new(sptr); // 这里会记录sptr的GetMem地址
  sptr^ := '123';
  sptr^ := '123456789'; // 在发生了对sptr的Realloc时，mh会寻找前后文，这里符合了realloc的记录条件，mh将记录它，并且在后续释放

  // mh支持控件创建和释放
  // mh不支持tform窗口释放，因为tform窗口会注册全局参数，mh在释放了tform以后，某些回调进来没有地址就会报错
  TButton.Create(Self).Free;

  Z.MH1.EndMemoryHook;

  Z.MH1.GetHookPtrList.ProgressP(procedure(NPtr: Pointer; uData: NativeUInt)
    begin
      // 现在我们可以释放该地址
      DoStatus(NPtr, uData, 80);
      FreeMem(NPtr);
    end);

  Z.MH1.GetHookPtrList.SetHashBlockCount(0);
end;

end.

 
